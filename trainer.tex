\documentclass[13pt,oneside,a4paper]{book}
\usepackage[margin=2cm]{geometry}
\usepackage{fontspec}
\usepackage[ddmmyyyy,hhmmss]{datetime}
\usepackage{lmodern}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{menukeys}
\usepackage{amsmath}
\usepackage{minted}

\hypersetup{
    colorlinks,
    citecolor=red,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}

\graphicspath{{./assets}}
\setlength{\parindent}{0pt}

\begin{document}
\begin{titlepage}
\begin{center}
        \pagebreak

        \hspace{0pt}
        \vfill
        {\fontsize{32pt}{10pt}\selectfont Group 3 Manual}\\
        \vspace{3cm}
        \textsc{\Large Mentored by} \\

        {\large Anshul, Ujjwal and Manas} \\
        \vspace{1cm}
        \textbf{Compiled~on~\today~at~\currenttime}

        \vspace*{\fill}
\end{center}

        {\fontsize{11pt}{10pt}\selectfont
               This document will be updated regularly so make sure you are viewing the latest copy. 
        }
\end{titlepage}

\pagenumbering{gobble}
\tableofcontents
\clearpage
\pagenumbering{arabic}

\chapter{Assignment 1}
\section{System Setup}
\begin{itemize}
        \item Install an editor/IDE
        \item Choose a Language
        \item Install a compiler
\end{itemize}

\clearpage

\chapter{Switching from C to C++}
\section{Why so serious?}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{c}
#include <stdio.h>

int main() {

        int n;
        long long m;
        char s[1000];

        scanf("%d%lld%s", &n, &m, &s);

        printf("%d %lld %s\n", n, s);

        return 0;
}
\end{minted}

becomes

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}

#include <bits/stdc++.h>
using namespace std;

int main() {

        int n;
        long long m;
        char s[1000];

        // a new data structure for strings which makes life easy
        string ss;

        cin >> n >> m >> s >> ss;

        cout << n << ' ' << m << ' ' << s << ' ' << ss << '\n';

        return 0;
}
\end{minted}

\section{C++ style strings}

In C++, the \textbf{string} data type is very similar to character arrays,
the only thing is here we do not have a NULL terminator. You get the following
new functionalities:

\smallskip

\mint{cpp}|string s = "Hello", s1 = "abcd", s2 = "abcd";|

\begin{itemize}
        \item append characters : \mint{cpp}|s += '2';|
        \item append string : \mint{cpp}|s += ", how are you?"|
        \item compare strings : \mint{cpp}|if(s1 == s2) cout << "Strings are equal!!\n";|
        \item indexing operator[~] : \mint{cpp}|for(int i = 0; i < s.length(); i++) { cout << s[i]; } cout << '\n';| will print all the characters of the string. But that is not how you print a string, you directly do \mint{cpp}|cout << s << '\n';|
\end{itemize}

\clearpage

\chapter{Assigment 2}
\section{How much do you know?}
The aim is to gauge your level of expertise so that we can provide everyone with what they want without wasting
anybody's time. Don't cheat or lie, it will defeat the purpose of the assignment.

\subsection{Level 1}
\begin{enumerate}
        \item \href{https://leetcode.com/problems/fibonacci-number/}{Fabonacci} \href{https://leetcode.com/problems/fibonacci-number/discuss/218301/C%2B%2B-4-Solutions-Explained-Recursive-or-Iterative-with-DP-or-Imperative-or-Binet's}{(Editorial)}
                \item \href{https://codeforces.com/contest/4/problem/A}{Watermelon} \href{https://leetcode.com/problems/fibonacci-number/discuss/218301/C%2B%2B-4-Solutions-Explained-Recursive-or-Iterative-with-DP-or-Imperative-or-Binet's}{(Editorial)}
\end{enumerate}

\subsection{Level 2}
\begin{enumerate}
        \item \href{https://leetcode.com/problems/move-zeroes/}{Zeroes to the end} If you do it in O(n\textsuperscript{2}) we won't mind, but leetcode might give a TLE. 
                
                \textbf{Editorial:} in O(n\textsuperscript{2}): Just like insertion sort, pick every non-zero element and put it at the correct position.
        \item \href{https://leetcode.com/problems/count-primes/}{Count Primes} \href{https://leetcode.com/problems/count-primes/discuss/57594/My-easy-one-round-c%2B%2B-code}{(Editorial)}
\end{enumerate}

\subsection{Level 3}
\begin{enumerate}
        \item \href{https://leetcode.com/problems/move-zeroes/}{Zeroes to the end} IMP: In a single linear O(n) traversal, Editorial : See Two Pointers Chapter
        \item \href{https://leetcode.com/problems/convert-to-base-2/}{Convert to base 2} \href{https://www.geeksforgeeks.org/convert-number-negative-base-representation/}{(Editorial)}
\end{enumerate}

Adding the entry to the google sheet

If you solved 1 from L1; 1, 2 from L2 and none from L3, you write it as \textbf{``10 11 00''}.\\
Someone who solves all will write \textbf{``11 11 11''} and will color his box green.\\
Partial solvers color their box blue.\\
Those who tried but solved none will color their's red.\\

This will be followed for all the future assignments. This assignment needs to be done within next 4 days, and then we will have a little discussion if required.

Indenting the code is very important, I personally follow the K\&R style but you can choose Google, LLVM or clang. Use your left pinky finger to hit the \keys{\tab} key.

\clearpage
 
\chapter{Baby Steps}
\section{Making I/O fast in C++}
These two lines of code can make your C++ runtimes faster by 50\%, you only notice
the difference on large testcases.

\begin{minted}{cpp}
        ios_base::sync_with_stdio(false);
        cin.tie(NULL), cout.tie(NULL);
\end{minted}

\section{A basic template file}

A template is a piece of code you can copy everytime you solve some problem.
\smallskip

If the  problem has no test cases:
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}
#include <bits/stdc++.h>
using namespace std;

#define fastIO ios_base::sync_with_stdio(0 && cin.tie(0) && cout.tie(0));

typedef long long ll;

int main() {
        fastIO;

        // insert your code here ....
        
        return 0;
}
\end{minted}

If the problem has test cases:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}

#include <bits/stdc++.h>
using namespace std;

#define fastIO ios_base::sync_with_stdio(0 && cin.tie(0) && cout.tie(0));

typedef long long ll;

// this solve() function can be treated exactly like main()
int solve() {
        
        // insert your code here
        
        return 0;
}

int main() {
        fastIO;

        int t;
        cin >> t;
        while(t--) {
                solve();
        }
        
        return 0;
}
\end{minted}

\hrule\bigskip

\section{Frequently seen numbers}

There are a few numbers like 10\textsuperscript{7}, 10\textsuperscript{9} + 7 (1000000007) , etc. which you
will frequently find in problems, we will discuss what they mean over here.

\begin{itemize}
        \item You can run 10\textsuperscript{7 to 8} iterations in around one second, so
                mostly you will see that they give size n of array equal to 10\textsuperscript{5} 
                and number of test cases of the order of 10\textsuperscript{3} or 10\textsuperscript{2}.
        \item 10\textsuperscript{9} + 7 (1000000007) is provided as a huge prime number you will need
                to take a modulo with of your answers in combinatorics type problems, where the answer can be so large
                that it will overflow the 64 bit integer (long long) too! You will need to know the modulo
                arithmetic rules for solving such problems. 998244353 is another prime number which might be
                found in a few problems.
        \item 10\textsuperscript{-9}~\leq~x~\leq~10\textsuperscript{9}, means you need to use \textbf{int} for storing x, anything
                larger than that goes inside the 64 bit \textbf{long long}, which will mostly be mentioned as x~\leq~10\textsuperscript{18}.
\end{itemize}

\section{Common Terminology}

I have added the ones which always confuse me, will add more as
they come to my mind.

\begin{itemize}
        \item \textbf{substring:} A continuous piece cut from a string. For e.g. ``abcd'' is a substring of ``aaabcdddeee'' but ``abcde'' is not
        \item \textbf{subsequence:} A discontinuous piece of an array or string. In the above example ``abcde'' is a subsequence of ``aaabcdddeee''.
        \item \textbf{subarray:} It is the \textbf{array} version of \textbf{substring}.
        \item \textbf{segment:} It is another name for a subarray.
\end{itemize}

\chapter{Assignment 3 : Two Pointers}

\section{Level 1}

\begin{itemize}
        \item \href{https://leetcode.com/problems/maximum-ascending-subarray-sum/}{Maximum Ascending Sum}
        \item \href{https://codeforces.com/problemset/problem/381/A}{Sereja and Dima}
\end{itemize}

\section{Level 2}

\subsection{Editorial for Zeroes problem}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        
        int n = nums.size();
        
        int src = 0, dest = 0;
        
        // src is the pointer which will always point to
        // non zero numbers, whereas dest will point to
        // the first occurence of zero at any moment
        // we pick the non-zero number from src and swap it with dest
        
        while(1) {
            
            // increment dest until the numbers are non-zero
            while(dest < n && nums[dest] != 0) 
                dest++;
            
            // this is common sense that src must always be greater than dest
            if(src < dest) src = dest + 1;
            
            // increment src until the it is zero
            while(src < n && nums[src] == 0) src++;
            
            // a check to ensure that src is within bounds
            // this is also the place where the code will break
            if(src >= n) break;
            
            // this is the inbuilt swap function of c++
            swap(nums[src], nums[dest]);
            
            dest++, src++;
            
        }
        
        return;
    }
};
\end{minted}

\bigskip

You might feel that it is not O(n) but O(n\textsuperscript{2}), so I say make a mini test case
and simulate it using the above code on paper.

\begin{itemize}
        \item \href{https://codeforces.com/problemset/problem/1462/A}{Favorite Sequence}
\end{itemize}

\section{Level 3}

\begin{itemize}
        \item \href{https://leetcode.com/problems/long-pressed-name/}{Long Pressed Name}
        \item \href{https://leetcode.com/problems/max-number-of-k-sum-pairs/}{Max number of k sum pairs}
\end{itemize}

\section{Level 4 - (HARD)}

\begin{itemize}
        \item \href{https://leetcode.com/problems/trapping-rain-water/}{Trapping Rain Water} This problem also has a stack solution.
\end{itemize}

It is recommended you spend enough time with the Level 3 and 4 problems, because they are going to stay for a long time
and are a key to many problems and logics.

\bigskip

\textbf{NOTE: }\\ 
\smallskip

This is how your use the inbuilt sort function for array \textbf{a} of size \textbf{n}.

\mint{cpp}|sort(a, a + n);|

\bigskip

Sorting in reverse.
\smallskip
Use:

\mint{cpp}|sort(a, a + n, greater<int>());|

or

\mint{cpp}|sort(a, a + n); reverse(a, a + n);|

A slight difference for sorting a vector \textbf{v}:

\mint{cpp}|sort(v.begin(), v.end());|

\chapter{std::map}

\section{What is dynamic programming?}

\textit{"If you forget the past, you are doomed to repeat it."}

But what are those problems called where you get the answer right without 
worrying about the future or the past? \textbf{answer: greedy problems}

Maps be it simple frequency arrays or std::map, help you save your past, so that you can always look back.

\section{K Sum Pair Problem}

Consider the \href{https://leetcode.com/problems/max-number-of-k-sum-pairs/}{Max number of k sum pairs} problem 
where you had to count the number of pairs in the array with sum k. You followed a two pointer approach 
where you sorted the array and then took two pointers which were moved from both sides towards the middle, until
 they meet.

 Time Complexity = \textbf{O(n * log2(n))} for sorting and \textbf{O(n)} for the two pointer iteration 
 which makes it \textbf{O(n * log2(n) + n)} \approx \textbf{O(n log2(n))} simply written as \textbf{O(n lg n)}.

\bigskip

Now what would have been the brute force approach?

\smallskip


\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}

// the array is not sorted
// Time O(n^2)

int number_of_pairs = 0;

int ans = 0;
for(int i = 1; i < n; i++) {

        // for each element see how many elements
        // before it if added to itself sum up to K
        for(int j = 0; j < i; j++) {
                if(a[j] > k) continue;

                if(a[i] + a[j] == k) 
                        ans++; 
        }
}
cout << ans << '\n';

\end{minted}

\bigskip

Now what if, as we move ahead in the array, we keep saving the 
frequencies for each element a[i], in a kind of \textbf{frequency array}.
A frequency array is an array of size \geq~\textbf{max(a[i])} and is filled with 
zeroes initially.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}

// max a[i] is 10^6
freq[(int)1e6] = {0};

// What you could also do; for older C++ versions
// memset(freq, 0, sizeof(freq));

int ans = 0;
for(int i = 0; i < n; i++) {
        if(a[i] > k) continue;

        // understand the next two statements properly!!!!!!!

        // for every complimentary element k - a[i] occurring before
        // we have a pair with a[i] hence,
        ans += freq[k - a[i]];

        // now save the current element's frequency
        // We do it in O(1)
        freq[a[i]]++;
}
\end{minted}

\smallskip

The time complexity of the above code is \textbf{O(max( n, max a[i] value)}.

Now we know that 10\textsuperscript{7} iterations usually run in a second or two, but what if a[i]
is very very large of the order 10\textsuperscript{18}? This is where the \textbf{std::map} comes to
 rescue.

 You will learn about Red-Black Trees in the DSA course (no you won't!). But for now, 
 imagine they are simple frequency arrays. The time complexity to saving a new element comes 
 down to \textbf{O(lg n)} but you now get to save huge elements.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos
]
{cpp}

// <key, value> : a key can be an object with a comparator only, and for value we 
// can have anything, a counter, or an address to some array anything!!!
map<int, int> mp;

mp.clear(); // this statement clears the map, use the same map for each test case
// and clear like this right at the beginning of solve()

int ans = 0;
for(int i = 0; i < n; i++) {
        if(a[i] > k) continue;

        // compare this code to the one above

        auto temp = mp.find(k - a[i]); // returns a map iterator to the pair <k - a[i], counter>
        // actually it must be
        // std::map<int, int>::iterator temp = mp.find(k - a[i]);
        // but C++ compilers are smart and auto will write that shit for you post-compilation

        // is temp a key in the map or not?
        // or does find give us the end of the map?
        if(temp != mp.end()) {
                ans += *temp.second; // pair<int, int> is the return type, 
                // use first and second to access values
                // also written as 
                // ans += temp->second;
        }

        // now save the current element's frequency
        // We do it in O(log n)
        mp[a[i]]++; // Like an array, map too provides 
        // the operator[](), but here it works in O(log n)

        // IMP : If you try to access an element not present in the map
        // using int value = mp[x].second; then you will get 0
        // the downside is it will add <x, 0> to the map too!
        // that is why you must find x first using mp.find() and then
        // change values, but if you are confident that an element x is
        // definitely present, then go ahead, nothing is stopping you
        // you can also use mp.count() > 0, read more on the internet
}

\end{minted}

\section{Read the following before attempting assignment 4}

\begin{itemize}
        \item Prefix sum arrays
        \item Finding range sum using prefix arrays
        \item Unordered maps, and why we must avoid them sometimes
        \item Side Mission : Learn the Kandane's Algorithm from GeeksForGeeks
\end{itemize}

Also, it is not always necessary to use std::map, for small values frequency arrays also work.

\chapter{Assignment 4 on std::map}

\subsection{Easy}

\href{https://leetcode.com/problems/kth-missing-positive-number/}{Kth Missing Positive Number}

\smallskip

\href{https://codeforces.com/problemset/problem/1430/C}{C. Numbers on the Whiteboard}

\subsection{Medium}

\href{https://codeforces.com/problemset/problem/1006/C}{C. Three Parts of an Array}

\smallskip

\href{https://codeforces.com/problemset/problem/961/B}{B. Lecture Sleep}

\subsection{Hard}

\href{https://codeforces.com/contest/1506/problem/D}{D. Epic Transformations}

\smallskip

\href{https://codeforces.com/problemset/problem/1279/C}{C. Stack of Presents}

\end{document}
